# Swift Macros: A Comprehensive Technical Analysis

## An Introduction to Swift Macros

Swift macros represent a paradigm shift in the language's approach to metaprogramming, providing a robust, safe, and deeply integrated system for compile-time code generation. Introduced in Swift 5.9, macros are a language feature designed to transform source code during the compilation process, enabling developers to automate the creation of repetitive or boilerplate code.[1, 2] This facility allows for the development of more expressive, readable, and maintainable codebases by abstracting away common patterns into reusable units.[3] The mechanism is one of direct source transformation; the Swift compiler expands all macros present in the source code *before* the standard build process continues, a critical distinction from runtime-based code generation techniques.[1, 4] The strategic importance of this feature is underscored by its adoption within Apple's own frameworks for flagship features such as `@Observable`, `#Preview`, and the SwiftData `@Model` macro, signaling a clear direction for future API design in the Swift ecosystem.[5]

### The Core Guarantees: A Foundation of Safety

The design of Swift macros is built upon a set of fundamental guarantees that ensure their use is predictable, safe, and consistent with the overall philosophy of the Swift language. These principles differentiate Swift macros from the less-constrained preprocessor systems of languages like C and Objective-C.[1]

  * **Additive Nature**: Macro expansion is exclusively an additive operation. A macro can introduce new code, but it is architecturally incapable of modifying or deleting existing code written by the developer.[1, 4, 5] This is a foundational constraint that prevents macros from having destructive or non-obvious side effects, ensuring that the developer's original source code remains the immutable source of truth.

  * **Syntactic Validity**: The Swift compiler rigorously validates both the input provided to a macro and the code generated by its expansion to ensure they are syntactically correct Swift code.[4] This safeguard prevents the injection of malformed code that would otherwise cause compilation failures in later stages, making the macro system more reliable.

  * **Type Safety**: In adherence with Swift's core principles, the macro system is fully type-safe. The compiler performs type checking on all values passed to a macro as arguments, as well as on the values and expressions within the code generated by the macro's expansion.[1, 4, 5] This eliminates a class of errors common in traditional text-substitution macro systems and ensures that generated code integrates seamlessly and correctly with the existing typed codebase.

  * **Integrated Error Handling**: Should a macro's implementation logic encounter an error during its expansion phase, this failure is not silent. The Swift compiler treats it as a standard compilation error, reporting it directly at the source location where the macro was invoked.[1, 4, 5] This tight integration makes debugging macro-related issues a first-class experience, akin to debugging any other language feature.

  * **Sandboxed Execution**: Macro implementations execute in a restricted, sandboxed environment during compilation. This sandbox prevents the macro from performing arbitrary side effects, such as accessing the file system or making network requests.[1] The macro's sole function is to operate on the Abstract Syntax Tree (AST) representation of the code it is given as input, ensuring its behavior is deterministic and confined to code transformation.

The confluence of these guarantees reveals a deliberate design philosophy prioritizing predictability and safety over the unbounded power of traditional preprocessors. The limitations—the inability to modify or delete code, the strict type and syntax checking, and the sandboxed execution—are not accidental omissions but intentional design choices. They represent a direct response to the historical pitfalls of C-style macros, which, through simple text substitution, could introduce subtle bugs, compromise type safety, and create code that was difficult to debug. By integrating macros into the compiler's type-checking and validation pipeline, Swift's designers have created a system for metaprogramming that upholds, rather than subverts, the language's core tenets of safety and clarity. This makes macros a tool for building robust and transparent abstractions, not for performing arbitrary and potentially unsafe code injection.

## The Anatomy of a Macro: Freestanding vs. Attached

The Swift macro system is bifurcated into two primary categories, distinguished by their syntax, purpose, and placement within source code: freestanding macros and attached macros. This fundamental division provides a clear mental model for how macros can be applied, with each category serving a distinct set of use cases.

### Freestanding Macros

Freestanding macros are self-contained and appear on their own in code, unattached to any specific declaration.[4, 6] They are invoked using a syntax that is intentionally reminiscent of other compile-time directives in Swift, such as conditional compilation blocks.

  * **Invocation Syntax**: A freestanding macro is called by prefixing its name with a number sign (`#`), followed by any arguments enclosed in parentheses. For example: `#function` or `#warning("This method is deprecated")`.[1, 4, 7]
  * **Purpose**: The function of a freestanding macro is either to produce a value, in which case it acts as an expression, or to perform a specific compile-time action.[1, 8] The `#function` macro, for instance, expands to a string literal containing the name of the enclosing function, while the `#warning` macro instructs the compiler to emit a custom warning message during the build process.
  * **Naming Convention**: By convention, freestanding macros adopt `lowerCamelCase` for their names. This aligns them with the naming conventions for functions and variables in Swift, reinforcing their conceptual similarity to function calls.[4, 6]

### Attached Macros

In contrast, attached macros are not standalone; they are applied directly to an existing declaration to modify or augment its behavior.[4, 6] Their syntax and application are designed to feel like a natural extension of Swift's existing attribute system.

  * **Invocation Syntax**: An attached macro is called by prefixing its name with an at sign (`@`), followed by any arguments in parentheses. This syntax is identical to that of attributes, for example: `@Observable` or `@OptionSet`.[1, 7]
  * **Purpose**: The primary purpose of an attached macro is to add new code to the declaration it modifies. This can include adding new methods, stored or computed properties, initializers, accessors, or adding conformance to one or more protocols.[1]
  * **Naming Convention**: Attached macros conventionally use `UpperCamelCase` for their names. This aligns them with the naming of types like structs, classes, and enums, reflecting their role in operating upon and modifying these kinds of declarations.[4, 6]

### Table: Freestanding vs. Attached Macros: A Comparative Overview

The following table provides a concise summary of the fundamental differences between the two macro categories, serving as a quick reference for selecting the appropriate type of macro for a given task.

| Feature | Freestanding Macros | Attached Macros |
| --- | --- | --- |
| **Invocation Syntax** | Number Sign (`#`) | At Sign (`@`) |
| **Appearance** | Standalone, like a function call or directive | "Attached" to a declaration, like an attribute |
| **Core Purpose** | Produce a value (expression) or perform an action | Modify or add to an existing declaration |
| **Naming Convention** | `lowerCamelCase` | `UpperCamelCase` |
| **Canonical Example** | `#function`, `#warning` | `@Observable`, `@main` |

## A Taxonomy of Macro Roles

Beyond the primary classification of freestanding and attached, the capabilities of a macro are further defined by its "roles." A role specifies precisely where a macro can be used in source code and what kind of code it is permitted to generate. Every macro declaration must specify one or more roles through the use of special attributes, which in turn correspond to specific protocols that the macro's implementation must conform to.[1, 4]

### Freestanding Macro Roles

Freestanding macros can be defined with one of two roles, governing whether they produce expressions or declarations.

  * `@freestanding(expression)`: This role is for macros that generate a piece of code that evaluates to a value. It is the most common type of freestanding macro. A well-known example from the standard library is `#stringify`, which takes an expression and produces a tuple containing both the result of the expression and a string representation of the expression's source code.[3, 9] Another practical example is a custom `#URL` macro that can validate a URL string at compile time, emitting a compiler error if the string is malformed and producing a non-optional `URL` instance if it is valid.[9]

  * `@freestanding(declaration)`: This role enables a macro to generate one or more complete, top-level declarations. Such a macro is not part of another expression but instead introduces new types, functions, or variables into the scope where it is called. A powerful use case would be a macro that accepts a JSON string as an argument and generates a full Swift `struct` or `class` that correctly models the structure of that JSON.[3, 5]

### Attached Macro Roles

Attached macros have a more diverse set of five roles, reflecting the various ways they can augment the declarations to which they are applied.

  * `@attached(member)`: A macro with the member role adds new declarations *inside* the scope of the type or extension it is attached to. This is the role used for adding new methods, properties, nested types, or initializers. For example, the standard library's `@OptionSet` macro uses this role to generate a required `init(rawValue:)` initializer.[1, 4] A custom macro could use this role to automatically synthesize a memberwise initializer for a struct that includes `private` properties, which the default initializer would ignore.[10]

  * `@attached(peer)`: The peer role allows a macro to add new declarations at the same scope level, *alongside* the declaration it is attached to. Unlike a member macro, the generated code is not nested within the original declaration. This is particularly useful for generating related helper types or functions. A common application is an `@AddAsync` macro that is attached to a function with a completion handler callback and generates a new, peer `async`/`await`-based variant of that same function.[3, 5, 11]

  * `@attached(accessor)`: This specialized role is for macros that add accessors (e.g., `get`, `set`, `willSet`, `didSet`) to a stored property. In doing so, it effectively transforms the stored property into a computed property, redirecting its storage or adding side effects to its access. This can be used to implement custom storage patterns, such as storing a property's value in a backing dictionary, or to automatically add observation logic.[3, 5]

  * `@attached(memberAttribute)`: A macro with the member attribute role does not add code directly, but instead adds other attributes to the *members* of the type it is attached to. For instance, a macro attached to a class could traverse all of its stored properties and apply a specific property wrapper attribute (like `@Published`) to each one, saving the developer from having to do so manually.[3, 5]

  * `@attached(conformance)` or `@attached(extension)`: This role is used to add protocol conformances to a type. The macro generates an `extension` for the type that declares the new conformance and can also generate the necessary properties or methods to satisfy the protocol's requirements. The `@OptionSet` macro, for example, uses this role to add an `extension ShippingOptions: OptionSet { }` block, thereby making the type conform to the `OptionSet` protocol.[1, 3, 4] When using this role, the `conformances` argument in the attribute is essential for informing the compiler of the protocols being added.[5]

### Table: Comprehensive Guide to Macro Roles

This table provides a definitive reference for the complete taxonomy of macro roles, linking each role's declaration-site attribute to its purpose and its corresponding implementation-site protocol.

| Role | Attribute Syntax | Category | Description | Implementation Protocol |
| --- | --- | --- | --- | --- |
| **Expression** | `@freestanding(expression)` | Freestanding | Generates an expression that produces a value. | `ExpressionMacro` |
| **Declaration** | `@freestanding(declaration)` | Freestanding | Generates one or more top-level declarations. | `DeclarationMacro` |
| **Peer** | `@attached(peer)` | Attached | Adds new declarations alongside the attached declaration. | `PeerMacro` |
| **Accessor** | `@attached(accessor)` | Attached | Adds accessors to a property. | `AccessorMacro` |
| **Member** | `@attached(member)` | Attached | Adds new members inside the attached type. | `MemberMacro` |
| **Member Attribute** | `@attached(memberAttribute)` | Attached | Adds attributes to the members of the attached type. | `MemberAttributeMacro` |
| **Conformance** | `@attached(conformance)` / `@attached(extension)` | Attached | Adds protocol conformances via a new extension. | `ExtensionMacro` |

## Declaring and Implementing Macros

The creation of a Swift macro involves a distinct separation of concerns into two key components: a public-facing declaration that defines the macro's API, and a separate implementation that contains the code-generation logic. This two-part structure is a departure from how most symbols are defined in Swift and is fundamental to the macro system's architecture.[1, 4]

### The Macro Declaration

The macro declaration serves as the public interface for the macro. It is what developers using the macro will see and interact with, and it provides the compiler with all the necessary metadata to understand the macro's purpose and connect it to its implementation.

  * **Syntax**: A macro is declared using the `public macro` keywords. Macros are invariably `public` because their implementation must reside in a different module from where they are used, necessitating a public access level.[4]
  * **Components**: The declaration specifies the macro's name, the parameters it accepts (defined with a function-like signature), its roles (specified via `@freestanding` or `@attached` attributes), and, critically, the location of its implementation logic.[4, 6]
  * **Implementation Link**: The link to the implementation is established using the `#externalMacro(module:type:)` macro. This directive tells the Swift compiler which module to load as a compiler plug-in (the `module` argument) and which type within that module contains the expansion logic (the `type` argument).[1, 4]

<!-- end list -->

```swift
// Example declaration for an attached member macro
@attached(member, names: named(init))
public macro MyMemberMacro() = #externalMacro(module: "MyMacrosPlugin", type: "MyMemberMacroImpl")
```

  * **Generated Names**: To improve tooling support like code completion and provide clearer intent, a macro declaration can specify the names of the symbols it will generate. This is done via the `names` argument to the role attribute. It can specify fixed names (e.g., `names: named(init)`) or patterns (e.g., `prefixed`, `suffixed`). If the names are determined dynamically based on the macro's input, the `arbitrary` value is used.[1, 4, 5]

### The Macro Implementation

The implementation contains the actual logic that transforms source code. It resides in a separate module that functions as a compiler plug-in, which is compiled and executed by the Swift compiler during the build process of any code that uses the macro.

  * **Compiler Plug-in Architecture**: The separation of declaration and implementation is a direct technical requirement of the compiler plug-in model. The client code depends on the macro's *declaration* to compile. However, to compile the client code, the compiler must execute the macro's *implementation*. This creates a potential build-order paradox. If both were in the same module, the module would depend on itself during compilation. By separating them, the cycle is broken: the implementation module is a build-time tool that is compiled first, and the client code then depends on the lightweight declaration module while being processed by the already-built plug-in.

  * **Swift Package Manager Setup**: The standard way to create macros is through Swift Package Manager. Xcode provides a "Swift Macro" package template that automatically configures the necessary project structure with two distinct targets: one for the public macro declarations (a standard library target) and a second for the implementation logic (a special `.macro` target).[3, 6, 12, 13]

  * **The Role of SwiftSyntax**: Macro implementations do not operate on raw source code strings. Instead, they interact with a structured, type-safe representation of the code known as an Abstract Syntax Tree (AST). This is facilitated by the **SwiftSyntax** library, which provides the tools to parse, inspect, traverse, and generate Swift source code programmatically.[3, 14, 15] The core task of a macro's implementation is to receive a `Syntax` node from the compiler, analyze its structure, and construct a new `Syntax` node that represents the expanded code. This reliance on SwiftSyntax means that developing non-trivial macros is fundamentally an exercise in programmatic AST manipulation. It requires a deep understanding of the grammatical structure of the Swift language itself, making tools like AST explorers essential for effective macro development.[15]

  * **Implementation Type and the `expansion` Method**: The implementation is defined as a type (typically a `struct` or `enum`) that conforms to one or more protocols from the `SwiftSyntaxMacros` module. The specific protocol(s) correspond directly to the roles declared for the macro (e.g., a macro with an `@attached(member)` role must have an implementation type that conforms to `MemberMacro`).[1, 14] Each of these protocols requires the implementation of a static `expansion(...)` method. This method is the entry point for the macro's logic. It receives the AST node of the macro call, the context of the declaration it is attached to (if any), and a context object used for emitting diagnostics like errors and warnings. The method's responsibility is to return a new AST node (or an array of nodes) representing the generated code.[1]

<!-- end list -->

```swift
// Example implementation for a simple member macro
import SwiftSyntax
import SwiftSyntaxMacros

public struct MyMemberMacroImpl: MemberMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        in context: some MacroExpansionContext
    ) throws -> {
        // Logic to analyze 'declaration' and generate new members
        let newInitializer: DeclSyntax = "init() { print(\"Hello from macro!\") }"
        return [newInitializer]
    }
}
```

## Under the Hood: The Macro Expansion Process

When the Swift compiler encounters a macro during a build, it initiates a sophisticated, multi-step process to expand the macro and integrate the generated code. This pipeline ensures that macro expansion is performed safely, correctly, and in a way that is fully compatible with the rest of the compilation workflow.

### The Seven-Step Expansion Pipeline

The expansion process can be broken down into a sequence of well-defined steps:

1.  **Parsing and AST Creation**: The process begins when the compiler reads a Swift source file. It parses the text and constructs an in-memory Abstract Syntax Tree (AST), which is a hierarchical, structured representation of the code. During this initial phase, the compiler verifies that the source code is syntactically valid Swift.[1, 4]

2.  **Macro Discovery**: With the AST constructed, the compiler traverses the tree to identify all instances of macro invocations. It looks for both freestanding macro calls (prefixed with `#`) and attached macro attributes (prefixed with `@`).[1]

3.  **Loading the Compiler Plug-in**: For each unique macro it discovers, the compiler consults the macro's declaration. It uses the information from the `#externalMacro(module:type:)` directive to locate and load the external binary—the compiled compiler plug-in—that contains the macro's implementation logic.[1]

4.  **Passing the AST to the Implementation**: The compiler then invokes the appropriate `expansion(...)` method within the loaded plug-in. It passes a portion of the main AST as an argument to this method. This partial AST precisely represents the macro call itself, including its arguments, and, for an attached macro, the entire declaration to which it is attached.[1]

5.  **Sandboxed Execution and Code Generation**: The macro's implementation logic executes within a secure sandbox, which restricts it from performing external operations like file or network I/O. The implementation analyzes the input AST it received and programmatically constructs a *new* AST that represents the generated Swift code. This new AST is the return value of the `expansion` method.[1]

6.  **AST Replacement**: The compiler receives the newly generated AST from the plug-in. It then modifies the main AST by replacing the original node that represented the macro call with the new tree of nodes representing the expanded code.[1]

7.  **Final Validation and Compilation**: After all macros have been expanded and the main AST has been modified, the compiler performs a final validation pass. It re-checks the entire tree to ensure it remains syntactically valid and that all types are correct and consistent. If these checks pass, this final, expanded AST is handed off to the subsequent stages of the compilation pipeline (e.g., SIL generation, optimization, and machine code generation).[1]

### Expansion Order

In cases where macros are nested—for example, a macro call appearing as an argument to another macro—the expansion order is deterministic: the **outermost macro is always expanded first**.[1] This behavior is significant because it allows the outer macro to potentially observe or even modify the inner macro call before the inner macro is itself expanded. This provides a predictable model for composing macros and reasoning about their interactions.

## Advanced Considerations and Best Practices

While the core mechanics of macros are straightforward, their effective application in real-world projects requires an understanding of the available tooling, performance characteristics, inherent limitations, and established best practices for development.

### Development and Debugging

The Swift toolchain provides essential features for developing and debugging macros, which are critical for working with generated code.

  * **Inspecting Generated Code**: The most crucial tool for understanding a macro's behavior is Xcode's "Expand Macro" feature. Accessible from the editor's context menu when right-clicking on a macro invocation, this command reveals the exact source code that the macro generated and inserted into the AST. This visibility is indispensable for both learning how a macro works and for diagnosing incorrect behavior.[6, 7, 9]

  * **Debugging Expanded Code**: Since the code generated by a macro is standard Swift code, it can be debugged using standard techniques. After expanding a macro in Xcode, developers can set breakpoints directly within the generated code. When the program is run, the debugger will pause at these breakpoints, allowing for inspection of variables and control flow just as with manually written code.[6, 7]

  * **Testing Macros**: The macro system is designed to be highly testable. The `SwiftSyntaxMacrosTestSupport` library, provided as part of the SwiftSyntax package, includes a vital function named `assertMacroExpansion`. This function facilitates the creation of unit tests for macros. A developer provides a string containing a sample usage of the macro and another string containing the expected expanded output. The test harness then invokes the macro and asserts that the generated code exactly matches the expected result. This enables a robust, test-driven development workflow for creating reliable macros.[3, 6, 16]

### Performance and Build Times

The use of macros introduces a new phase into the compilation process, which can have an impact on build performance.

  * **Compile-Time Cost**: By definition, macros execute at compile time. Complex macros that perform significant AST analysis or generate large amounts of code can increase the overall build time for a project.[1]
  * **Dependency Overhead**: The macro implementation itself must be compiled. This process involves compiling the macro's logic and linking against the substantial `SwiftSyntax` library, which can add a noticeable delay, particularly during the first build of the macro plug-in.[1]
  * **Expansion Caching**: To mitigate the performance impact on incremental builds, the Swift build system employs a caching mechanism for macro expansions. The code generated by a macro is cached after its first expansion. On subsequent builds, the macro will only be re-expanded if its own implementation has changed or if the specific site of its usage in the client code has been modified. This caching helps to avoid redundant work and makes the development process more efficient.[5]

### Known Limitations and Constraints

The macro system, while powerful, has several intentional limitations designed to ensure safety and predictability.

  * **Limited Scope**: An attached macro's visibility is strictly confined to the declaration to which it is attached. It cannot "see" or access information about other declarations in the same file, nor can it inspect parent types or protocols that a type inherits from. Its context is local and well-defined.[5]
  * **Expansion Availability**: The code generated by one macro is not available to another macro during the same compilation pass. This means macros cannot be chained in a way where one macro's output serves as another's input within a single build phase. For example, a macro that generates a new property cannot be followed by a second macro that attempts to read or modify that same, just-generated property.[5]
  * **Explicit Code Constraints**: Some language features or even other macros may require the presence of explicit code in the source file, and will not be satisfied by code that is generated by a macro. For instance, the SwiftData `@Model` macro requires an initializer to be present. Applying a separate macro to generate that initializer might not satisfy the `@Model` macro's compile-time check, which may be looking for the `init` in the pre-expansion source code.[5]

### Best Practices

To ensure that macros enhance rather than complicate a codebase, developers should adhere to several best practices.

  * **Prioritize Clear Intent**: Macros should be designed with a clear and obvious purpose. Avoid creating overly complex or "magical" macros that obscure the underlying behavior of the code. The name of the macro and its documentation should make its function readily apparent.[2, 6]
  * **Provide Excellent Diagnostics**: A robust macro should anticipate incorrect usage. It should validate its inputs and, if it detects a problem, use the `MacroExpansionContext` API to throw descriptive, actionable errors. Well-crafted diagnostics can guide the user directly to a fix, greatly improving the developer experience.[3]
  * **Utilize SwiftSyntaxBuilder**: When generating code inside an `expansion` method, it is possible to construct the new AST from formatted strings. However, a more reliable and type-safe approach is to use the `SwiftSyntaxBuilder` API. This API provides a declarative, result-builder-style syntax for constructing `Syntax` nodes, which helps prevent the accidental generation of syntactically invalid code.[5]

## Discrepancy and Evolution Report

This final section addresses anomalies encountered during the data collection phase for this report and provides a summary of the Swift macro feature's state and evolution since its public introduction.

### Discrepancy in Data Collection

A significant discrepancy was noted during the initial information gathering stage.

  * **Primary Finding**: The primary URL specified for data extraction, `https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros`, was repeatedly found to be inaccessible or to return empty content during automated analysis attempts.[4, 17] This prevented a direct, live scrape of the official documentation page.

  * **Resolution Strategy**: To overcome this issue, the content for this report was meticulously reconstructed. This was achieved by synthesizing information from various reliable sources, including cached fragments and summaries of the official documentation that were successfully extracted in prior research.[1, 4] This reconstructed core was then cross-referenced, validated, and enriched with supplementary technical details from official WWDC presentation materials, in-depth articles from reputable engineering blogs, and discussions from official developer forums. Consequently, this report represents a high-fidelity synthesis of the canonical information, rather than a direct snapshot of the target URL at a single point in time.

### Evolution of Macros Since Swift 5.9

The macro system has been a focus of development and refinement since its introduction.

  * **Introduction in Swift 5.9**: Macros were officially introduced as a major new language feature with the release of Swift 5.9 in September 2023.[1, 8, 18] This initial release included the complete set of seven freestanding and attached macro roles as detailed in this report, providing a comprehensive foundation for compile-time metaprogramming.

  * **Ecosystem Challenges**: Following the release, as the developer community began to adopt macros in larger and more complex projects, certain practical challenges emerged. The most prominent of these are concerns about the impact of complex macros on project build times and issues related to dependency management, specifically the need to align a macro's `SwiftSyntax` library version with that used by the developer's version of Xcode.[18] These areas represent active topics of discussion and are likely candidates for future improvements in the toolchain.

  * **Enhancements in Swift 6**: The release of Swift 6, while primarily focused on major advancements in concurrency safety and memory management, continues to build upon the macro system.[19, 20, 21] The research indicates no fundamental changes to the core architecture or the existing set of macro roles. Instead, the evolution has focused on expanding the utility of macros by introducing new built-in macros that improve the developer experience.

  * **New Built-in Macro: `@debugDescription`**: A notable addition in Swift 6 is the `@debugDescription` macro. When this macro is attached to a custom type, it provides a hint to the LLDB debugger. It instructs the debugger to use the value of the type's `debugDescription` property as the primary summary string displayed in Xcode's variable viewer during a debugging session. This allows developers to easily customize how complex objects are represented in the debugger, greatly simplifying the inspection of their state.[22]

The introduction of `@debugDescription` is indicative of a broader trend in the evolution of macros. It demonstrates their application not just for client-side code generation, but also as a powerful mechanism for enhancing the integration between source code and development tools. The future direction for macros appears to be centered on improving the stability and performance of the existing system while strategically adding new, high-value built-in macros that solve common and persistent developer pain points.[18, 23] The core system introduced in Swift 5.9 remains the stable and powerful foundation upon which these incremental improvements are being built.